/*
 * ╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
 * ║                                                                                                                ║
 * ║                              FPSFlux Universal Compatibility Layer                                             ║
 * ║                              HandlerBridge — Runtime Bytecode Bridge                                           ║
 * ║                                                                                                                ║
 * ║  Location: com/example/modid/mixins/compat/HandlerBridge.java                                                  ║
 * ║  Internal Name: com/example/modid/mixins/compat/HandlerBridge                                                  ║
 * ║                                                                                                                ║
 * ║  PURPOSE:                                                                                                      ║
 * ║  ─────────                                                                                                     ║
 * ║  This class serves as the critical runtime bridge between ASM-generated wrapper bytecode                      ║
 * ║  and the FPSFlux handler chain. When the compatibility layer transforms an @Overwrite                         ║
 * ║  method, the generated bytecode calls into this class to:                                                     ║
 * ║    1. Acquire a zero-allocation OperationContext from the pool                                                ║
 * ║    2. Execute the FPSFlux handler chain                                                                       ║
 * ║    3. Determine if the operation was handled (should return early) or not (call original)                     ║
 * ║    4. Release the context back to the pool                                                                    ║
 * ║                                                                                                                ║
 * ║  DESIGN REQUIREMENTS:                                                                                          ║
 * ║  ────────────────────                                                                                          ║
 * ║    • ZERO ALLOCATION in hot paths (context pooling)                                                           ║
 * ║    • THREAD SAFE (concurrent access from multiple render threads)                                             ║
 * ║    • EXCEPTION SAFE (never crashes, always falls back to original implementation)                             ║
 * ║    • COMPREHENSIVE LOGGING (bytecode transformation details to ByteCodeLogs.log)                              ║
 * ║    • MINIMAL OVERHEAD (< 100ns per invocation when not handled)                                               ║
 * ║                                                                                                                ║
 * ║  BYTECODE ACCESS:                                                                                              ║
 * ║  ────────────────                                                                                              ║
 * ║  Generated bytecode uses these method signatures:                                                             ║
 * ║    • acquireContext()  → ()Lcom/example/modid/mixins/compat/HandlerBridge$OperationContext;                   ║
 * ║    • releaseContext(ctx) → (Lcom/example/modid/mixins/compat/HandlerBridge$OperationContext;)V                ║
 * ║    • handleOperation(ctx) → (Lcom/example/modid/mixins/compat/HandlerBridge$OperationContext;)Z               ║
 * ║                                                                                                                ║
 * ╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
 */

package com.example.modid.mixins.compat;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.function.Supplier;

/**
 * HandlerBridge — The critical runtime interface for FPSFlux compatibility layer.
 * 
 * <p>This class provides the public static entry points that ASM-generated wrapper
 * bytecode calls into. It manages:
 * <ul>
 *   <li>Zero-allocation context pooling for operation parameters</li>
 *   <li>Thread-safe handler chain execution</li>
 *   <li>Comprehensive bytecode transformation logging</li>
 *   <li>Performance metrics and statistics</li>
 * </ul>
 * 
 * <p><b>Thread Safety:</b> All public methods are thread-safe and lock-free in the
 * common case (context acquisition uses atomic operations on a ring buffer).
 * 
 * <p><b>Performance:</b> Target overhead is &lt;100ns per handleOperation call when
 * the operation is not handled (pass-through to original implementation).
 * 
 * @author FPSFlux Team
 * @version 2.0.0
 * @since FPSFlux 2.0
 */
public final class HandlerBridge {
    
    private HandlerBridge() {
        throw new UnsupportedOperationException("HandlerBridge is a static utility class");
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 1 — CONSTANTS & CONFIGURATION
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /** Internal class name for bytecode generation */
    public static final String INTERNAL_NAME = "com/example/modid/mixins/compat/HandlerBridge";
    
    /** Internal name of OperationContext for bytecode generation */
    public static final String CONTEXT_INTERNAL_NAME = INTERNAL_NAME + "$OperationContext";
    
    /** Context descriptor for bytecode generation */
    public static final String CONTEXT_DESCRIPTOR = "L" + CONTEXT_INTERNAL_NAME + ";";
    
    /** Method descriptors for bytecode generation */
    public static final String ACQUIRE_CONTEXT_DESC = "()" + CONTEXT_DESCRIPTOR;
    public static final String RELEASE_CONTEXT_DESC = "(" + CONTEXT_DESCRIPTOR + ")V";
    public static final String HANDLE_OPERATION_DESC = "(" + CONTEXT_DESCRIPTOR + ")Z";
    
    /** Global context pool size (power of 2 for efficient modulo) */
    private static final int GLOBAL_POOL_SIZE = 256;
    
    /** Thread-local pool size (smaller, per-thread) */
    private static final int THREAD_LOCAL_POOL_SIZE = 16;
    
    /** Maximum parameter array sizes */
    private static final int MAX_INT_PARAMS = 16;
    private static final int MAX_FLOAT_PARAMS = 16;
    private static final int MAX_LONG_PARAMS = 8;
    private static final int MAX_DOUBLE_PARAMS = 8;
    
    /** Log file path */
    private static final String BYTECODE_LOG_FILE = "ByteCodeLogs.log";
    
    /** Enable detailed bytecode logging */
    private static volatile boolean bytecodeLoggingEnabled = true;
    
    /** Enable performance metrics */
    private static volatile boolean metricsEnabled = true;
    
    /** Debug mode flag */
    private static final boolean DEBUG_MODE = Boolean.getBoolean("fpsflux.debug");
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 2 — OPERATION ENUM
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * Enumeration of all graphics operations that can be intercepted.
     * Each operation corresponds to a GlStateManager/RenderSystem method.
     */
    public enum Operation {
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // BLEND OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_BLEND("enableBlend", "()V", Category.BLEND),
        DISABLE_BLEND("disableBlend", "()V", Category.BLEND),
        BLEND_FUNC("blendFunc", "(II)V", Category.BLEND),
        BLEND_FUNC_SEPARATE("blendFuncSeparate", "(IIII)V", Category.BLEND),
        BLEND_EQUATION("blendEquation", "(I)V", Category.BLEND),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // DEPTH OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_DEPTH_TEST("enableDepthTest", "()V", Category.DEPTH),
        DISABLE_DEPTH_TEST("disableDepthTest", "()V", Category.DEPTH),
        DEPTH_FUNC("depthFunc", "(I)V", Category.DEPTH),
        DEPTH_MASK("depthMask", "(Z)V", Category.DEPTH),
        CLEAR_DEPTH("clearDepth", "(D)V", Category.DEPTH),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // CULL OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_CULL_FACE("enableCull", "()V", Category.CULL),
        DISABLE_CULL_FACE("disableCull", "()V", Category.CULL),
        CULL_FACE("cullFace", "(I)V", Category.CULL),
        FRONT_FACE("frontFace", "(I)V", Category.CULL),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // ALPHA TEST OPERATIONS (Legacy)
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_ALPHA_TEST("enableAlpha", "()V", Category.ALPHA),
        DISABLE_ALPHA_TEST("disableAlpha", "()V", Category.ALPHA),
        ALPHA_FUNC("alphaFunc", "(IF)V", Category.ALPHA),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // TEXTURE OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_TEXTURE_2D("enableTexture2D", "()V", Category.TEXTURE),
        DISABLE_TEXTURE_2D("disableTexture2D", "()V", Category.TEXTURE),
        BIND_TEXTURE("bindTexture", "(I)V", Category.TEXTURE),
        DELETE_TEXTURE("deleteTexture", "(I)V", Category.TEXTURE),
        ACTIVE_TEXTURE("activeTexture", "(I)V", Category.TEXTURE),
        TEX_PARAMETER("texParameter", "(III)V", Category.TEXTURE),
        TEX_IMAGE_2D("texImage2D", "(IIIIIIIILjava/nio/ByteBuffer;)V", Category.TEXTURE),
        TEX_SUB_IMAGE_2D("texSubImage2D", "(IIIIIIIILjava/nio/ByteBuffer;)V", Category.TEXTURE),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // SCISSOR OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_SCISSOR_TEST("enableScissorTest", "()V", Category.SCISSOR),
        DISABLE_SCISSOR_TEST("disableScissorTest", "()V", Category.SCISSOR),
        SCISSOR("scissor", "(IIII)V", Category.SCISSOR),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // STENCIL OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_STENCIL_TEST("enableStencilTest", "()V", Category.STENCIL),
        DISABLE_STENCIL_TEST("disableStencilTest", "()V", Category.STENCIL),
        STENCIL_FUNC("stencilFunc", "(III)V", Category.STENCIL),
        STENCIL_OP("stencilOp", "(III)V", Category.STENCIL),
        STENCIL_MASK("stencilMask", "(I)V", Category.STENCIL),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // COLOR OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        COLOR("color", "(FFFF)V", Category.COLOR),
        COLOR_3F("color3f", "(FFF)V", Category.COLOR),
        COLOR_4F("color4f", "(FFFF)V", Category.COLOR),
        COLOR_MASK("colorMask", "(ZZZZ)V", Category.COLOR),
        CLEAR_COLOR("clearColor", "(FFFF)V", Category.COLOR),
        RESET_COLOR("resetColor", "()V", Category.COLOR),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // MATRIX OPERATIONS (Legacy/Compatibility)
        // ════════════════════════════════════════════════════════════════════════════════════════════
        PUSH_MATRIX("pushMatrix", "()V", Category.MATRIX),
        POP_MATRIX("popMatrix", "()V", Category.MATRIX),
        LOAD_IDENTITY("loadIdentity", "()V", Category.MATRIX),
        MATRIX_MODE("matrixMode", "(I)V", Category.MATRIX),
        TRANSLATE_F("translatef", "(FFF)V", Category.MATRIX),
        TRANSLATE_D("translated", "(DDD)V", Category.MATRIX),
        SCALE_F("scalef", "(FFF)V", Category.MATRIX),
        SCALE_D("scaled", "(DDD)V", Category.MATRIX),
        ROTATE_F("rotatef", "(FFFF)V", Category.MATRIX),
        ROTATE_D("rotated", "(DDDD)V", Category.MATRIX),
        MULT_MATRIX("multMatrix", "(Ljava/nio/FloatBuffer;)V", Category.MATRIX),
        ORTHO("ortho", "(DDDDDD)V", Category.MATRIX),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // VIEWPORT OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        VIEWPORT("viewport", "(IIII)V", Category.VIEWPORT),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // CLEAR OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        CLEAR("clear", "(I)V", Category.CLEAR),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // LIGHTING OPERATIONS (Legacy)
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_LIGHTING("enableLighting", "()V", Category.LIGHTING),
        DISABLE_LIGHTING("disableLighting", "()V", Category.LIGHTING),
        ENABLE_LIGHT("enableLight", "(I)V", Category.LIGHTING),
        DISABLE_LIGHT("disableLight", "(I)V", Category.LIGHTING),
        LIGHT("light", "(IILjava/nio/FloatBuffer;)V", Category.LIGHTING),
        LIGHT_MODEL("lightModel", "(ILjava/nio/FloatBuffer;)V", Category.LIGHTING),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // FOG OPERATIONS (Legacy)
        // ════════════════════════════════════════════════════════════════════════════════════════════
        ENABLE_FOG("enableFog", "()V", Category.FOG),
        DISABLE_FOG("disableFog", "()V", Category.FOG),
        FOG("fog", "(ILjava/nio/FloatBuffer;)V", Category.FOG),
        FOG_MODE("fogMode", "(I)V", Category.FOG),
        FOG_DENSITY("fogDensity", "(F)V", Category.FOG),
        FOG_START("fogStart", "(F)V", Category.FOG),
        FOG_END("fogEnd", "(F)V", Category.FOG),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // SHADER/PROGRAM OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        USE_PROGRAM("useProgram", "(I)V", Category.SHADER),
        SET_SHADER("setShader", "(Ljava/util/function/Supplier;)V", Category.SHADER),
        SET_SHADER_COLOR("setShaderColor", "(FFFF)V", Category.SHADER),
        SET_SHADER_TEXTURE("setShaderTexture", "(II)V", Category.SHADER),
        SET_SHADER_FOG_START("setShaderFogStart", "(F)V", Category.SHADER),
        SET_SHADER_FOG_END("setShaderFogEnd", "(F)V", Category.SHADER),
        SET_SHADER_FOG_COLOR("setShaderFogColor", "(FFFF)V", Category.SHADER),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // BUFFER OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        BIND_BUFFER("bindBuffer", "(II)V", Category.BUFFER),
        BUFFER_DATA("bufferData", "(ILjava/nio/ByteBuffer;I)V", Category.BUFFER),
        BIND_VERTEX_ARRAY("bindVertexArray", "(I)V", Category.BUFFER),
        ENABLE_VERTEX_ATTRIB_ARRAY("enableVertexAttribArray", "(I)V", Category.BUFFER),
        DISABLE_VERTEX_ATTRIB_ARRAY("disableVertexAttribArray", "(I)V", Category.BUFFER),
        VERTEX_ATTRIB_POINTER("vertexAttribPointer", "(IIIZIJ)V", Category.BUFFER),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // FRAMEBUFFER OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        BIND_FRAMEBUFFER("bindFramebuffer", "(II)V", Category.FRAMEBUFFER),
        FRAMEBUFFER_TEXTURE_2D("framebufferTexture2D", "(IIIII)V", Category.FRAMEBUFFER),
        BLIT_FRAMEBUFFER("blitFramebuffer", "(IIIIIIIIII)V", Category.FRAMEBUFFER),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // DRAW OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        DRAW_ARRAYS("drawArrays", "(III)V", Category.DRAW),
        DRAW_ELEMENTS("drawElements", "(IIIJ)V", Category.DRAW),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // QUERY OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        GET_INTEGER("getInteger", "(I)I", Category.QUERY),
        GET_FLOAT("getFloat", "(I)F", Category.QUERY),
        GET_STRING("getString", "(I)Ljava/lang/String;", Category.QUERY),
        GET_ERROR("getError", "()I", Category.QUERY),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // MISC OPERATIONS
        // ════════════════════════════════════════════════════════════════════════════════════════════
        LINE_WIDTH("lineWidth", "(F)V", Category.MISC),
        POINT_SIZE("pointSize", "(F)V", Category.MISC),
        POLYGON_MODE("polygonMode", "(II)V", Category.MISC),
        POLYGON_OFFSET("polygonOffset", "(FF)V", Category.MISC),
        ENABLE_POLYGON_OFFSET("enablePolygonOffset", "()V", Category.MISC),
        DISABLE_POLYGON_OFFSET("disablePolygonOffset", "()V", Category.MISC),
        SHADE_MODEL("shadeModel", "(I)V", Category.MISC),
        LOGIC_OP("logicOp", "(I)V", Category.MISC),
        PIXEL_STORE("pixelStore", "(II)V", Category.MISC),
        READ_PIXELS("readPixels", "(IIIIIILjava/nio/ByteBuffer;)V", Category.MISC),
        FLUSH("flush", "()V", Category.MISC),
        FINISH("finish", "()V", Category.MISC),
        
        // ════════════════════════════════════════════════════════════════════════════════════════════
        // SPECIAL/UNKNOWN
        // ════════════════════════════════════════════════════════════════════════════════════════════
        UNKNOWN("unknown", "()V", Category.UNKNOWN);
        
        public enum Category {
            BLEND, DEPTH, CULL, ALPHA, TEXTURE, SCISSOR, STENCIL, COLOR,
            MATRIX, VIEWPORT, CLEAR, LIGHTING, FOG, SHADER, BUFFER,
            FRAMEBUFFER, DRAW, QUERY, MISC, UNKNOWN
        }
        
        private final String methodName;
        private final String descriptor;
        private final Category category;
        
        Operation(String methodName, String descriptor, Category category) {
            this.methodName = methodName;
            this.descriptor = descriptor;
            this.category = category;
        }
        
        public String getMethodName() { return methodName; }
        public String getDescriptor() { return descriptor; }
        public Category getCategory() { return category; }
        
        /** Lookup map for fast method name resolution */
        private static final Map<String, Operation> BY_METHOD_NAME = new ConcurrentHashMap<>();
        
        static {
            for (Operation op : values()) {
                BY_METHOD_NAME.put(op.methodName.toLowerCase(), op);
                // Also add common variations
                BY_METHOD_NAME.put(op.methodName, op);
                BY_METHOD_NAME.put("_" + op.methodName, op);
                BY_METHOD_NAME.put("gl" + capitalize(op.methodName), op);
            }
        }
        
        private static String capitalize(String s) {
            if (s == null || s.isEmpty()) return s;
            return Character.toUpperCase(s.charAt(0)) + s.substring(1);
        }
        
        /**
         * Find operation by method name (case-insensitive).
         */
        public static Operation fromMethodName(String methodName) {
            if (methodName == null) return UNKNOWN;
            
            // Remove common prefixes
            String normalized = methodName
                .replace("_", "")
                .replace("GL", "")
                .replace("gl", "")
                .toLowerCase();
            
            Operation op = BY_METHOD_NAME.get(methodName.toLowerCase());
            if (op != null) return op;
            
            op = BY_METHOD_NAME.get(normalized);
            if (op != null) return op;
            
            // Try partial matching
            for (Operation candidate : values()) {
                if (candidate.methodName.toLowerCase().contains(normalized) ||
                    normalized.contains(candidate.methodName.toLowerCase())) {
                    return candidate;
                }
            }
            
            return UNKNOWN;
        }
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 3 — OPERATION CONTEXT
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * OperationContext — Container for operation parameters and results.
     * 
     * <p>This class is designed for zero-allocation pooling. Instances are created once
     * at startup and reused throughout the application lifetime.
     * 
     * <p><b>Parameter Layout:</b>
     * <ul>
     *   <li>intParams[0-15]: Integer parameters (also used for boolean, byte, short, char)</li>
     *   <li>floatParams[0-15]: Float parameters</li>
     *   <li>longParams[0-7]: Long parameters</li>
     *   <li>doubleParams[0-7]: Double parameters</li>
     *   <li>objectParam: First object parameter (Buffer, String, etc.)</li>
     *   <li>objectParams[0-3]: Additional object parameters</li>
     * </ul>
     * 
     * <p><b>Thread Safety:</b> Individual contexts are NOT thread-safe. Each thread
     * should acquire its own context from the pool.
     */
    public static final class OperationContext {
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // OPERATION IDENTIFICATION
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** The operation being performed */
        public Operation operation;
        
        /** Source class name (for debugging) */
        public String sourceClass;
        
        /** Source method name (for debugging) */
        public String sourceMethod;
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // PRIMITIVE PARAMETERS
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** Integer parameters (includes boolean, byte, short, char) */
        public final int[] intParams = new int[MAX_INT_PARAMS];
        
        /** Float parameters */
        public final float[] floatParams = new float[MAX_FLOAT_PARAMS];
        
        /** Long parameters */
        public final long[] longParams = new long[MAX_LONG_PARAMS];
        
        /** Double parameters */
        public final double[] doubleParams = new double[MAX_DOUBLE_PARAMS];
        
        /** Parameter counts (for variable-argument methods) */
        public int intParamCount;
        public int floatParamCount;
        public int longParamCount;
        public int doubleParamCount;
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // OBJECT PARAMETERS
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** Primary object parameter (most common: Buffer, Matrix, etc.) */
        public Object objectParam;
        
        /** Secondary object parameters (for complex methods) */
        public final Object[] objectParams = new Object[4];
        
        /** Object parameter count */
        public int objectParamCount;
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // RESULT VALUES
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** Integer result */
        public int resultInt;
        
        /** Float result */
        public float resultFloat;
        
        /** Long result */
        public long resultLong;
        
        /** Double result */
        public double resultDouble;
        
        /** Object result */
        public Object resultObject;
        
        /** Boolean result (stored as int for efficiency) */
        public int resultBoolean;
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // STATUS & ERROR HANDLING
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** Was this operation handled by the chain? */
        public boolean handled;
        
        /** Should the original implementation be skipped? */
        public boolean cancelled;
        
        /** Error message if operation failed */
        public String errorMessage;
        
        /** Exception if operation threw */
        public Throwable exception;
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // TIMING & METRICS
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** Timestamp when context was acquired (for metrics) */
        public long acquireTimeNanos;
        
        /** Frame number when acquired */
        public long frameNumber;
        
        /** Thread ID that acquired this context */
        public long threadId;
        
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        // POOL MANAGEMENT
        // ═══════════════════════════════════════════════════════════════════════════════════════════
        
        /** Index in the pool (for debugging) */
        int poolIndex;
        
        /** Is this context currently in use? (for debugging) */
        volatile boolean inUse;
        
        /**
         * Reset this context for reuse.
         * Called automatically by acquireContext().
         */
        public void reset() {
            operation = null;
            sourceClass = null;
            sourceMethod = null;
            
            // Don't need to reset primitive arrays - they're overwritten by generated code
            intParamCount = 0;
            floatParamCount = 0;
            longParamCount = 0;
            doubleParamCount = 0;
            
            objectParam = null;
            Arrays.fill(objectParams, null);
            objectParamCount = 0;
            
            resultInt = 0;
            resultFloat = 0f;
            resultLong = 0L;
            resultDouble = 0.0;
            resultObject = null;
            resultBoolean = 0;
            
            handled = false;
            cancelled = false;
            errorMessage = null;
            exception = null;
            
            acquireTimeNanos = 0L;
            frameNumber = 0L;
            threadId = 0L;
            
            inUse = false;
        }
        
        /**
         * Create a debug string representation of this context.
         */
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder(256);
            sb.append("OperationContext{");
            sb.append("op=").append(operation);
            sb.append(", intParams=[");
            for (int i = 0; i < intParamCount; i++) {
                if (i > 0) sb.append(", ");
                sb.append(intParams[i]);
            }
            sb.append("], floatParams=[");
            for (int i = 0; i < floatParamCount; i++) {
                if (i > 0) sb.append(", ");
                sb.append(floatParams[i]);
            }
            sb.append("], handled=").append(handled);
            sb.append(", cancelled=").append(cancelled);
            sb.append("}");
            return sb.toString();
        }
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 4 — CONTEXT POOLING
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * Global context pool (ring buffer with atomic index).
     * Used when thread-local pool is exhausted.
     */
    private static final OperationContext[] globalPool = new OperationContext[GLOBAL_POOL_SIZE];
    private static final AtomicInteger globalPoolIndex = new AtomicInteger(0);
    
    /**
     * Thread-local context pool for reduced contention.
     * Each thread gets its own small pool before falling back to global.
     */
    private static final ThreadLocal<ThreadLocalPool> threadLocalPools = 
        ThreadLocal.withInitial(ThreadLocalPool::new);
    
    /**
     * Thread-local pool implementation.
     */
    private static final class ThreadLocalPool {
        final OperationContext[] pool = new OperationContext[THREAD_LOCAL_POOL_SIZE];
        int index = 0;
        
        ThreadLocalPool() {
            for (int i = 0; i < THREAD_LOCAL_POOL_SIZE; i++) {
                pool[i] = new OperationContext();
                pool[i].poolIndex = i;
            }
        }
        
        OperationContext acquire() {
            OperationContext ctx = pool[index];
            index = (index + 1) & (THREAD_LOCAL_POOL_SIZE - 1);
            return ctx;
        }
    }
    
    // Initialize global pool
    static {
        for (int i = 0; i < GLOBAL_POOL_SIZE; i++) {
            globalPool[i] = new OperationContext();
            globalPool[i].poolIndex = THREAD_LOCAL_POOL_SIZE + i;
        }
        
        // Initialize logging
        initializeLogging();
    }
    
    /**
     * Acquire an OperationContext from the pool.
     * 
     * <p><b>Thread Safety:</b> This method is thread-safe and lock-free.
     * 
     * <p><b>Allocation:</b> Zero allocation - contexts are pre-created and reused.
     * 
     * <p><b>Bytecode Signature:</b> ()Lcom/example/modid/mixins/compat/HandlerBridge$OperationContext;
     * 
     * @return A reset OperationContext ready for use
     */
    public static OperationContext acquireContext() {
        // Try thread-local pool first (faster, no contention)
        OperationContext ctx;
        try {
            ctx = threadLocalPools.get().acquire();
        } catch (Throwable t) {
            // Fallback to global pool if thread-local fails
            int idx = globalPoolIndex.getAndIncrement() & (GLOBAL_POOL_SIZE - 1);
            ctx = globalPool[idx];
        }
        
        ctx.reset();
        ctx.inUse = true;
        ctx.acquireTimeNanos = System.nanoTime();
        ctx.threadId = Thread.currentThread().getId();
        
        if (metricsEnabled) {
            Metrics.contextAcquisitions.incrementAndGet();
        }
        
        return ctx;
    }
    
    /**
     * Release an OperationContext back to the pool.
     * 
     * <p><b>Thread Safety:</b> This method is thread-safe.
     * 
     * <p><b>Bytecode Signature:</b> (Lcom/example/modid/mixins/compat/HandlerBridge$OperationContext;)V
     * 
     * @param ctx The context to release
     */
    public static void releaseContext(OperationContext ctx) {
        if (ctx == null) return;
        
        if (metricsEnabled) {
            long duration = System.nanoTime() - ctx.acquireTimeNanos;
            Metrics.totalContextTimeNanos.addAndGet(duration);
            Metrics.contextReleases.incrementAndGet();
        }
        
        // Clear object references to help GC
        ctx.objectParam = null;
        Arrays.fill(ctx.objectParams, null);
        ctx.resultObject = null;
        ctx.exception = null;
        ctx.inUse = false;
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 5 — HANDLER CHAIN EXECUTION
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * Handler function interface.
     */
    @FunctionalInterface
    public interface OperationHandler {
        /**
         * Handle an operation.
         * 
         * @param ctx The operation context
         * @return true if handled (original should be skipped), false otherwise
         */
        boolean handle(OperationContext ctx);
    }
    
    /**
     * Registered handlers, sorted by priority (highest first).
     */
    private static final int MAX_HANDLERS = 64;
    private static final OperationHandler[] handlers = new OperationHandler[MAX_HANDLERS];
    private static final String[] handlerNames = new String[MAX_HANDLERS];
    private static final int[] handlerPriorities = new int[MAX_HANDLERS];
    private static final AtomicInteger handlerCount = new AtomicInteger(0);
    
    /**
     * Execute the handler chain for an operation.
     * 
     * <p><b>Thread Safety:</b> This method is thread-safe.
     * 
     * <p><b>Error Handling:</b> If any handler throws, the exception is caught,
     * logged, and execution continues with the next handler. This ensures that
     * one broken handler doesn't break the entire chain.
     * 
     * <p><b>Bytecode Signature:</b> (Lcom/example/modid/mixins/compat/HandlerBridge$OperationContext;)Z
     * 
     * @param ctx The operation context
     * @return true if the operation was handled (caller should return), false otherwise
     */
    public static boolean handleOperation(OperationContext ctx) {
        if (ctx == null) {
            if (DEBUG_MODE) {
                logError("handleOperation called with null context");
            }
            return false;
        }
        
        if (ctx.operation == null) {
            if (DEBUG_MODE) {
                logError("handleOperation called with null operation");
            }
            return false;
        }
        
        if (metricsEnabled) {
            Metrics.operationsProcessed.incrementAndGet();
            Metrics.operationCounts.computeIfAbsent(ctx.operation, k -> new AtomicLong()).incrementAndGet();
        }
        
        long startTime = 0;
        if (metricsEnabled) {
            startTime = System.nanoTime();
        }
        
        try {
            int count = handlerCount.get();
            
            for (int i = 0; i < count; i++) {
                OperationHandler handler = handlers[i];
                if (handler == null) continue;
                
                try {
                    boolean handled = handler.handle(ctx);
                    
                    if (handled) {
                        ctx.handled = true;
                        ctx.cancelled = true;
                        
                        if (metricsEnabled) {
                            Metrics.operationsHandled.incrementAndGet();
                            Metrics.handlerHits.computeIfAbsent(handlerNames[i], k -> new AtomicLong()).incrementAndGet();
                        }
                        
                        if (DEBUG_MODE) {
                            logDebug("Operation {} handled by {}", ctx.operation, handlerNames[i]);
                        }
                        
                        return true;
                    }
                } catch (Throwable t) {
                    // Log but continue to next handler
                    logError("Handler {} threw exception for {}: {}", 
                        handlerNames[i], ctx.operation, t.getMessage());
                    
                    if (metricsEnabled) {
                        Metrics.handlerErrors.incrementAndGet();
                    }
                }
            }
            
            // No handler handled the operation
            if (metricsEnabled) {
                Metrics.operationsPassedThrough.incrementAndGet();
            }
            
            return false;
            
        } finally {
            if (metricsEnabled) {
                long duration = System.nanoTime() - startTime;
                Metrics.totalHandlerTimeNanos.addAndGet(duration);
            }
        }
    }
    
    /**
     * Register a handler with the chain.
     * 
     * @param name Handler name (for debugging)
     * @param priority Priority (higher = called first)
     * @param handler The handler function
     * @return Handler ID, or -1 if registration failed
     */
    public static synchronized int registerHandler(String name, int priority, OperationHandler handler) {
        if (handler == null) return -1;
        
        int count = handlerCount.get();
        if (count >= MAX_HANDLERS) {
            logError("Cannot register handler {}: max handlers reached", name);
            return -1;
        }
        
        // Find insertion point (sorted by priority descending)
        int insertIdx = count;
        for (int i = 0; i < count; i++) {
            if (priority > handlerPriorities[i]) {
                insertIdx = i;
                break;
            }
        }
        
        // Shift existing handlers
        for (int i = count; i > insertIdx; i--) {
            handlers[i] = handlers[i - 1];
            handlerNames[i] = handlerNames[i - 1];
            handlerPriorities[i] = handlerPriorities[i - 1];
        }
        
        // Insert new handler
        handlers[insertIdx] = handler;
        handlerNames[insertIdx] = name != null ? name : "handler_" + insertIdx;
        handlerPriorities[insertIdx] = priority;
        handlerCount.incrementAndGet();
        
        logInfo("Registered handler '{}' at priority {} (index {})", name, priority, insertIdx);
        logBytecodeEvent("HANDLER_REGISTERED", name, 
            "priority=" + priority + ", index=" + insertIdx);
        
        return insertIdx;
    }
    
    /**
     * Unregister a handler by index.
     */
    public static synchronized boolean unregisterHandler(int handlerId) {
        int count = handlerCount.get();
        if (handlerId < 0 || handlerId >= count) return false;
        
        String name = handlerNames[handlerId];
        
        // Shift handlers down
        for (int i = handlerId; i < count - 1; i++) {
            handlers[i] = handlers[i + 1];
            handlerNames[i] = handlerNames[i + 1];
            handlerPriorities[i] = handlerPriorities[i + 1];
        }
        
        handlers[count - 1] = null;
        handlerNames[count - 1] = null;
        handlerPriorities[count - 1] = 0;
        handlerCount.decrementAndGet();
        
        logInfo("Unregistered handler '{}'", name);
        logBytecodeEvent("HANDLER_UNREGISTERED", name, "");
        
        return true;
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 6 — BYTECODE LOGGING SYSTEM
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * Bytecode log writer.
     */
    private static volatile PrintWriter bytecodeLogWriter;
    private static final Object logLock = new Object();
    private static final DateTimeFormatter LOG_TIME_FORMAT = 
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");
    
    /**
     * Initialize the bytecode logging system.
     */
    private static void initializeLogging() {
        try {
            Path logPath = Paths.get(BYTECODE_LOG_FILE);
            bytecodeLogWriter = new PrintWriter(new BufferedWriter(
                new OutputStreamWriter(
                    Files.newOutputStream(logPath, StandardOpenOption.CREATE, 
                        StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE),
                    StandardCharsets.UTF_8
                ), 65536 // 64KB buffer
            ), false); // Don't auto-flush
            
            // Write header
            writeBytecodeLogHeader();
            
        } catch (IOException e) {
            System.err.println("[FPSFlux] Failed to initialize bytecode log: " + e.getMessage());
            bytecodeLoggingEnabled = false;
        }
    }
    
    /**
     * Write the bytecode log header.
     */
    private static void writeBytecodeLogHeader() {
        if (bytecodeLogWriter == null) return;
        
        synchronized (logLock) {
            bytecodeLogWriter.println("╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗");
            bytecodeLogWriter.println("║                                                                                                                  ║");
            bytecodeLogWriter.println("║                              FPSFLUX BYTECODE TRANSFORMATION LOG                                                 ║");
            bytecodeLogWriter.println("║                              ════════════════════════════════════                                                ║");
            bytecodeLogWriter.println("║                                                                                                                  ║");
            bytecodeLogWriter.println("║  This log contains detailed information about bytecode transformations performed by the                         ║");
            bytecodeLogWriter.println("║  FPSFlux Universal Compatibility Layer. It records:                                                             ║");
            bytecodeLogWriter.println("║    • Class transformations (which classes were modified)                                                        ║");
            bytecodeLogWriter.println("║    • Method transformations (which methods were wrapped)                                                        ║");
            bytecodeLogWriter.println("║    • Generated bytecode instructions (ASM instructions generated)                                               ║");
            bytecodeLogWriter.println("║    • Handler registrations/executions                                                                           ║");
            bytecodeLogWriter.println("║    • Errors and warnings                                                                                        ║");
            bytecodeLogWriter.println("║                                                                                                                  ║");
            bytecodeLogWriter.println("║  Generated: " + LocalDateTime.now().format(LOG_TIME_FORMAT) + "                                                                   ║");
            bytecodeLogWriter.println("║  Bridge Class: " + INTERNAL_NAME + "                                          ║");
            bytecodeLogWriter.println("║                                                                                                                  ║");
            bytecodeLogWriter.println("╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝");
            bytecodeLogWriter.println();
            bytecodeLogWriter.flush();
        }
    }
    
    /**
     * Log a bytecode event.
     */
    public static void logBytecodeEvent(String eventType, String target, String details) {
        if (!bytecodeLoggingEnabled || bytecodeLogWriter == null) return;
        
        synchronized (logLock) {
            String timestamp = LocalDateTime.now().format(LOG_TIME_FORMAT);
            bytecodeLogWriter.printf("[%s] [Bytecode|%-5s] %s: %s%n", 
                timestamp, eventType, target, details);
        }
    }
    
    /**
     * Log a class transformation.
     */
    public static void logClassTransformation(String className, int originalSize, int transformedSize,
                                              int methodsTransformed, long timeNanos) {
        if (!bytecodeLoggingEnabled || bytecodeLogWriter == null) return;
        
        synchronized (logLock) {
            String timestamp = LocalDateTime.now().format(LOG_TIME_FORMAT);
            
            bytecodeLogWriter.println();
            bytecodeLogWriter.println("════════════════════════════════════════════════════════════════════════════════════════════════════════════════");
            bytecodeLogWriter.printf("[%s] CLASS TRANSFORMATION%n", timestamp);
            bytecodeLogWriter.println("════════════════════════════════════════════════════════════════════════════════════════════════════════════════");
            bytecodeLogWriter.printf("  Class:               %s%n", className);
            bytecodeLogWriter.printf("  Original Size:       %d bytes%n", originalSize);
            bytecodeLogWriter.printf("  Transformed Size:    %d bytes%n", transformedSize);
            bytecodeLogWriter.printf("  Size Delta:          %+d bytes (%.1f%%)%n", 
                transformedSize - originalSize,
                ((transformedSize - originalSize) * 100.0 / originalSize));
            bytecodeLogWriter.printf("  Methods Transformed: %d%n", methodsTransformed);
            bytecodeLogWriter.printf("  Transform Time:      %.3f ms%n", timeNanos / 1_000_000.0);
            bytecodeLogWriter.println("════════════════════════════════════════════════════════════════════════════════════════════════════════════════");
            bytecodeLogWriter.println();
            bytecodeLogWriter.flush();
        }
    }
    
    /**
     * Log a method transformation with full bytecode details.
     */
    public static void logMethodTransformation(String className, String methodName, String descriptor,
                                                String backupName, Operation operation,
                                                List<String> generatedInstructions) {
        if (!bytecodeLoggingEnabled || bytecodeLogWriter == null) return;
        
        synchronized (logLock) {
            String timestamp = LocalDateTime.now().format(LOG_TIME_FORMAT);
            
            bytecodeLogWriter.println();
            bytecodeLogWriter.println("────────────────────────────────────────────────────────────────────────────────────────────────────────────────");
            bytecodeLogWriter.printf("[%s] METHOD TRANSFORMATION%n", timestamp);
            bytecodeLogWriter.println("────────────────────────────────────────────────────────────────────────────────────────────────────────────────");
            bytecodeLogWriter.printf("  Class:           %s%n", className);
            bytecodeLogWriter.printf("  Method:          %s%n", methodName);
            bytecodeLogWriter.printf("  Descriptor:      %s%n", descriptor);
            bytecodeLogWriter.printf("  Backup Method:   %s%n", backupName);
            bytecodeLogWriter.printf("  Operation:       %s%n", operation != null ? operation.name() : "UNKNOWN");
            bytecodeLogWriter.printf("  Category:        %s%n", operation != null ? operation.getCategory() : "UNKNOWN");
            bytecodeLogWriter.println();
            bytecodeLogWriter.println("  Generated Bytecode Instructions:");
            bytecodeLogWriter.println("  ─────────────────────────────────");
            
            int instrIndex = 0;
            for (String instruction : generatedInstructions) {
                bytecodeLogWriter.printf("    %04d: %s%n", instrIndex++, instruction);
            }
            
            bytecodeLogWriter.println();
            bytecodeLogWriter.println("────────────────────────────────────────────────────────────────────────────────────────────────────────────────");
            bytecodeLogWriter.flush();
        }
    }
    
    /**
     * Generate and log bytecode instructions for a wrapper method.
     */
    public static List<String> generateAndLogWrapperBytecode(String className, String methodName,
                                                              String descriptor, String backupName,
                                                              Operation operation, boolean isStatic) {
        List<String> instructions = new ArrayList<>(64);
        int instrOffset = 0;
        
        // Parse descriptor
        String returnType = extractReturnType(descriptor);
        String[] paramTypes = extractParamTypes(descriptor);
        boolean returnsVoid = returnType.equals("V");
        
        // Calculate local variable slots
        int localSlot = isStatic ? 0 : 1;
        for (String param : paramTypes) {
            localSlot += getTypeSize(param);
        }
        int contextSlot = localSlot;
        int exceptionSlot = contextSlot + 1;
        
        instructions.add("// ═══════════════════════════════════════════════════════════════════════════════");
        instructions.add("// WRAPPER METHOD: " + methodName + descriptor);
        instructions.add("// Generated by FPSFlux Universal Compatibility Layer");
        instructions.add("// ═══════════════════════════════════════════════════════════════════════════════");
        instructions.add("");
        
        // Section 1: Acquire Context
        instructions.add("// SECTION 1: Acquire OperationContext (Zero Allocation)");
        instructions.add(String.format("%04d: INVOKESTATIC %s.acquireContext %s", 
            instrOffset++, INTERNAL_NAME, ACQUIRE_CONTEXT_DESC));
        instructions.add(String.format("%04d: ASTORE %d                    // Store ctx in local %d", 
            instrOffset++, contextSlot, contextSlot));
        instructions.add("");
        
        // Section 2: Try-Finally Setup
        instructions.add("// SECTION 2: Setup Try-Finally Block (ensures context release)");
        instructions.add(String.format("%04d: LABEL L_TRY_START", instrOffset++));
        instructions.add(String.format("%04d: TRYCATCHBLOCK L_TRY_START L_TRY_END L_FINALLY null", instrOffset++));
        instructions.add("");
        
        // Section 3: Set Operation
        instructions.add("// SECTION 3: Set Operation on Context");
        instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
        instructions.add(String.format("%04d: GETSTATIC %s$Operation.%s : L%s$Operation;", 
            instrOffset++, INTERNAL_NAME, operation.name(), INTERNAL_NAME));
        instructions.add(String.format("%04d: PUTFIELD %s.operation : L%s$Operation;", 
            instrOffset++, CONTEXT_INTERNAL_NAME, INTERNAL_NAME));
        instructions.add("");
        
        // Section 4: Set Parameters
        instructions.add("// SECTION 4: Copy Parameters to Context");
        int paramSlot = isStatic ? 0 : 1;
        int intParamIdx = 0, floatParamIdx = 0, longParamIdx = 0, doubleParamIdx = 0;
        
        for (int i = 0; i < paramTypes.length; i++) {
            String paramType = paramTypes[i];
            
            switch (paramType) {
                case "I", "Z", "B", "C", "S" -> {
                    instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
                    instructions.add(String.format("%04d: GETFIELD %s.intParams : [I", instrOffset++, CONTEXT_INTERNAL_NAME));
                    instructions.add(String.format("%04d: BIPUSH %d                    // Array index %d", instrOffset++, intParamIdx, intParamIdx));
                    instructions.add(String.format("%04d: %sLOAD %d                   // Load param %d (%s)", 
                        instrOffset++, getLoadPrefix(paramType), paramSlot, i, paramType));
                    instructions.add(String.format("%04d: IASTORE                     // Store in intParams[%d]", instrOffset++, intParamIdx));
                    intParamIdx++;
                }
                case "F" -> {
                    instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
                    instructions.add(String.format("%04d: GETFIELD %s.floatParams : [F", instrOffset++, CONTEXT_INTERNAL_NAME));
                    instructions.add(String.format("%04d: BIPUSH %d                    // Array index %d", instrOffset++, floatParamIdx, floatParamIdx));
                    instructions.add(String.format("%04d: FLOAD %d                    // Load param %d (F)", instrOffset++, paramSlot, i));
                    instructions.add(String.format("%04d: FASTORE                     // Store in floatParams[%d]", instrOffset++, floatParamIdx));
                    floatParamIdx++;
                }
                case "J" -> {
                    instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
                    instructions.add(String.format("%04d: GETFIELD %s.longParams : [J", instrOffset++, CONTEXT_INTERNAL_NAME));
                    instructions.add(String.format("%04d: BIPUSH %d                    // Array index %d", instrOffset++, longParamIdx, longParamIdx));
                    instructions.add(String.format("%04d: LLOAD %d                    // Load param %d (J)", instrOffset++, paramSlot, i));
                    instructions.add(String.format("%04d: LASTORE                     // Store in longParams[%d]", instrOffset++, longParamIdx));
                    longParamIdx++;
                }
                case "D" -> {
                    instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
                    instructions.add(String.format("%04d: GETFIELD %s.doubleParams : [D", instrOffset++, CONTEXT_INTERNAL_NAME));
                    instructions.add(String.format("%04d: BIPUSH %d                    // Array index %d", instrOffset++, doubleParamIdx, doubleParamIdx));
                    instructions.add(String.format("%04d: DLOAD %d                    // Load param %d (D)", instrOffset++, paramSlot, i));
                    instructions.add(String.format("%04d: DASTORE                     // Store in doubleParams[%d]", instrOffset++, doubleParamIdx));
                    doubleParamIdx++;
                }
                default -> {
                    // Object type
                    instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
                    instructions.add(String.format("%04d: ALOAD %d                    // Load param %d (Object)", instrOffset++, paramSlot, i));
                    instructions.add(String.format("%04d: PUTFIELD %s.objectParam : Ljava/lang/Object;", instrOffset++, CONTEXT_INTERNAL_NAME));
                }
            }
            
            paramSlot += getTypeSize(paramType);
        }
        instructions.add("");
        
        // Section 5: Call Handler Chain
        instructions.add("// SECTION 5: Execute FPSFlux Handler Chain");
        instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
        instructions.add(String.format("%04d: INVOKESTATIC %s.handleOperation %s", 
            instrOffset++, INTERNAL_NAME, HANDLE_OPERATION_DESC));
        instructions.add("");
        
        // Section 6: Check Result
        instructions.add("// SECTION 6: Check if Operation was Handled");
        instructions.add(String.format("%04d: IFEQ L_NOT_HANDLED          // If false, jump to call original", instrOffset++));
        instructions.add("");
        
        // Section 7: Handled Path - Return Early
        instructions.add("// SECTION 7: Operation Handled - Release Context and Return");
        instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
        instructions.add(String.format("%04d: INVOKESTATIC %s.releaseContext %s", 
            instrOffset++, INTERNAL_NAME, RELEASE_CONTEXT_DESC));
        
        if (returnsVoid) {
            instructions.add(String.format("%04d: RETURN                      // Return void", instrOffset++));
        } else {
            // Get result from context
            instructions.add(String.format("%04d: ALOAD %d                     // Load ctx for result", instrOffset++, contextSlot));
            String resultField = getResultField(returnType);
            instructions.add(String.format("%04d: GETFIELD %s.%s", instrOffset++, CONTEXT_INTERNAL_NAME, resultField));
            if (returnType.startsWith("L") || returnType.startsWith("[")) {
                instructions.add(String.format("%04d: CHECKCAST %s              // Cast result", instrOffset++, returnType));
            }
            instructions.add(String.format("%04d: %sRETURN                    // Return result", instrOffset++, getReturnPrefix(returnType)));
        }
        instructions.add("");
        
        // Section 8: Not Handled Path
        instructions.add("// SECTION 8: Not Handled - Call Original @Overwrite Implementation");
        instructions.add(String.format("%04d: LABEL L_NOT_HANDLED", instrOffset++));
        instructions.add(String.format("%04d: FRAME SAME", instrOffset++));
        instructions.add(String.format("%04d: LABEL L_TRY_END", instrOffset++));
        
        // Release context
        instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
        instructions.add(String.format("%04d: INVOKESTATIC %s.releaseContext %s", 
            instrOffset++, INTERNAL_NAME, RELEASE_CONTEXT_DESC));
        
        // Load arguments for backup call
        instructions.add("");
        instructions.add("// Load arguments for backup method call");
        paramSlot = isStatic ? 0 : 1;
        if (!isStatic) {
            instructions.add(String.format("%04d: ALOAD 0                     // Load 'this'", instrOffset++));
        }
        for (int i = 0; i < paramTypes.length; i++) {
            String paramType = paramTypes[i];
            String prefix = getLoadPrefix(paramType);
            instructions.add(String.format("%04d: %sLOAD %d                   // Load arg %d (%s)", 
                instrOffset++, prefix, paramSlot, i, paramType));
            paramSlot += getTypeSize(paramType);
        }
        
        // Call backup method
        String invokeType = isStatic ? "INVOKESTATIC" : "INVOKEVIRTUAL";
        instructions.add(String.format("%04d: %s %s.%s %s", 
            instrOffset++, invokeType, className.replace('.', '/'), backupName, descriptor));
        
        // Return
        if (returnsVoid) {
            instructions.add(String.format("%04d: RETURN", instrOffset++));
        } else {
            instructions.add(String.format("%04d: %sRETURN", instrOffset++, getReturnPrefix(returnType)));
        }
        
        // Jump over finally
        instructions.add(String.format("%04d: GOTO L_END", instrOffset++));
        instructions.add("");
        
        // Section 9: Finally Handler (Exception Path)
        instructions.add("// SECTION 9: Finally Handler (Exception Path)");
        instructions.add(String.format("%04d: LABEL L_FINALLY", instrOffset++));
        instructions.add(String.format("%04d: FRAME SAME1 java/lang/Throwable", instrOffset++));
        instructions.add(String.format("%04d: ASTORE %d                    // Store exception", instrOffset++, exceptionSlot));
        instructions.add(String.format("%04d: ALOAD %d                     // Load ctx", instrOffset++, contextSlot));
        instructions.add(String.format("%04d: INVOKESTATIC %s.releaseContext %s", 
            instrOffset++, INTERNAL_NAME, RELEASE_CONTEXT_DESC));
        instructions.add(String.format("%04d: ALOAD %d                    // Load exception", instrOffset++, exceptionSlot));
        instructions.add(String.format("%04d: ATHROW                       // Re-throw exception", instrOffset++));
        instructions.add("");
        
        // Section 10: End
        instructions.add("// SECTION 10: Method End");
        instructions.add(String.format("%04d: LABEL L_END", instrOffset++));
        instructions.add(String.format("%04d: FRAME SAME", instrOffset++));
        
        int maxStack = Math.max(6, paramTypes.length + 4);
        int maxLocals = exceptionSlot + 1;
        instructions.add(String.format("%04d: MAXS %d %d                   // maxStack=%d, maxLocals=%d", 
            instrOffset++, maxStack, maxLocals, maxStack, maxLocals));
        instructions.add(String.format("%04d: END_METHOD", instrOffset));
        
        // Log the transformation
        logMethodTransformation(className, methodName, descriptor, backupName, operation, instructions);
        
        return instructions;
    }
    
    // Helper methods for bytecode generation
    
    private static String extractReturnType(String descriptor) {
        int idx = descriptor.lastIndexOf(')');
        return descriptor.substring(idx + 1);
    }
    
    private static String[] extractParamTypes(String descriptor) {
        List<String> types = new ArrayList<>();
        int idx = 1; // Skip '('
        while (idx < descriptor.length() && descriptor.charAt(idx) != ')') {
            char c = descriptor.charAt(idx);
            if (c == 'L') {
                int end = descriptor.indexOf(';', idx);
                types.add(descriptor.substring(idx, end + 1));
                idx = end + 1;
            } else if (c == '[') {
                int start = idx;
                idx++;
                while (descriptor.charAt(idx) == '[') idx++;
                if (descriptor.charAt(idx) == 'L') {
                    int end = descriptor.indexOf(';', idx);
                    types.add(descriptor.substring(start, end + 1));
                    idx = end + 1;
                } else {
                    types.add(descriptor.substring(start, idx + 1));
                    idx++;
                }
            } else {
                types.add(String.valueOf(c));
                idx++;
            }
        }
        return types.toArray(new String[0]);
    }
    
    private static int getTypeSize(String type) {
        return (type.equals("J") || type.equals("D")) ? 2 : 1;
    }
    
    private static String getLoadPrefix(String type) {
        return switch (type) {
            case "I", "Z", "B", "C", "S" -> "I";
            case "F" -> "F";
            case "J" -> "L";
            case "D" -> "D";
            default -> "A";
        };
    }
    
    private static String getReturnPrefix(String type) {
        return switch (type) {
            case "V" -> "";
            case "I", "Z", "B", "C", "S" -> "I";
            case "F" -> "F";
            case "J" -> "L";
            case "D" -> "D";
            default -> "A";
        };
    }
    
    private static String getResultField(String type) {
        return switch (type) {
            case "I", "Z", "B", "C", "S" -> "resultInt : I";
            case "F" -> "resultFloat : F";
            case "J" -> "resultLong : J";
            case "D" -> "resultDouble : D";
            default -> "resultObject : Ljava/lang/Object;";
        };
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 7 — METRICS
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * Performance metrics for the handler bridge.
     */
    public static final class Metrics {
        private Metrics() {}
        
        // Context pool metrics
        public static final AtomicLong contextAcquisitions = new AtomicLong(0);
        public static final AtomicLong contextReleases = new AtomicLong(0);
        public static final AtomicLong totalContextTimeNanos = new AtomicLong(0);
        
        // Handler metrics
        public static final AtomicLong operationsProcessed = new AtomicLong(0);
        public static final AtomicLong operationsHandled = new AtomicLong(0);
        public static final AtomicLong operationsPassedThrough = new AtomicLong(0);
        public static final AtomicLong handlerErrors = new AtomicLong(0);
        public static final AtomicLong totalHandlerTimeNanos = new AtomicLong(0);
        
        // Per-operation counts
        public static final ConcurrentHashMap<Operation, AtomicLong> operationCounts = new ConcurrentHashMap<>();
        
        // Per-handler hit counts
        public static final ConcurrentHashMap<String, AtomicLong> handlerHits = new ConcurrentHashMap<>();
        
        // Transformation metrics
        public static final AtomicLong classesTransformed = new AtomicLong(0);
        public static final AtomicLong methodsTransformed = new AtomicLong(0);
        public static final AtomicLong transformationErrors = new AtomicLong(0);
        public static final AtomicLong totalTransformTimeNanos = new AtomicLong(0);
        
        /**
         * Get a summary of all metrics.
         */
        public static String getSummary() {
            StringBuilder sb = new StringBuilder(4096);
            
            sb.append("╔══════════════════════════════════════════════════════════════════════════════╗\n");
            sb.append("║                    HANDLER BRIDGE METRICS SUMMARY                            ║\n");
            sb.append("╠══════════════════════════════════════════════════════════════════════════════╣\n");
            
            sb.append("║  CONTEXT POOL:                                                               ║\n");
            sb.append(String.format("║    Acquisitions:       %,15d                                   ║%n", contextAcquisitions.get()));
            sb.append(String.format("║    Releases:           %,15d                                   ║%n", contextReleases.get()));
            sb.append(String.format("║    Avg Time:           %,15.2f µs                              ║%n", 
                contextAcquisitions.get() > 0 ? (totalContextTimeNanos.get() / (double) contextAcquisitions.get() / 1000.0) : 0));
            
            sb.append("╠══════════════════════════════════════════════════════════════════════════════╣\n");
            sb.append("║  HANDLER CHAIN:                                                              ║\n");
            sb.append(String.format("║    Operations Processed: %,13d                                   ║%n", operationsProcessed.get()));
            sb.append(String.format("║    Operations Handled:   %,13d                                   ║%n", operationsHandled.get()));
            sb.append(String.format("║    Pass Through:         %,13d                                   ║%n", operationsPassedThrough.get()));
            sb.append(String.format("║    Errors:               %,13d                                   ║%n", handlerErrors.get()));
            sb.append(String.format("║    Handle Rate:          %,13.2f %%                               ║%n", 
                operationsProcessed.get() > 0 ? (operationsHandled.get() * 100.0 / operationsProcessed.get()) : 0));
            sb.append(String.format("║    Avg Handler Time:     %,13.2f µs                              ║%n", 
                operationsProcessed.get() > 0 ? (totalHandlerTimeNanos.get() / (double) operationsProcessed.get() / 1000.0) : 0));
            
            sb.append("╠══════════════════════════════════════════════════════════════════════════════╣\n");
            sb.append("║  TRANSFORMATIONS:                                                            ║\n");
            sb.append(String.format("║    Classes Transformed:  %,13d                                   ║%n", classesTransformed.get()));
            sb.append(String.format("║    Methods Transformed:  %,13d                                   ║%n", methodsTransformed.get()));
            sb.append(String.format("║    Errors:               %,13d                                   ║%n", transformationErrors.get()));
            sb.append(String.format("║    Total Transform Time: %,13.2f ms                              ║%n", totalTransformTimeNanos.get() / 1_000_000.0));
            
            sb.append("╚══════════════════════════════════════════════════════════════════════════════╝\n");
            
            return sb.toString();
        }
        
        /**
         * Reset all metrics.
         */
        public static void reset() {
            contextAcquisitions.set(0);
            contextReleases.set(0);
            totalContextTimeNanos.set(0);
            operationsProcessed.set(0);
            operationsHandled.set(0);
            operationsPassedThrough.set(0);
            handlerErrors.set(0);
            totalHandlerTimeNanos.set(0);
            operationCounts.clear();
            handlerHits.clear();
            classesTransformed.set(0);
            methodsTransformed.set(0);
            transformationErrors.set(0);
            totalTransformTimeNanos.set(0);
        }
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 8 — LOGGING UTILITIES
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    private static void logInfo(String format, Object... args) {
        log("INFO ", format, args);
    }
    
    private static void logDebug(String format, Object... args) {
        if (DEBUG_MODE) {
            log("DEBUG", format, args);
        }
    }
    
    private static void logError(String format, Object... args) {
        log("ERROR", format, args);
    }
    
    private static void log(String level, String format, Object... args) {
        String message = formatMessage(format, args);
        String timestamp = LocalDateTime.now().format(LOG_TIME_FORMAT);
        String logLine = String.format("[%s] [HandlerBridge|%s] %s", timestamp, level, message);
        
        // Print to console
        System.out.println(logLine);
        
        // Write to bytecode log
        if (bytecodeLogWriter != null) {
            synchronized (logLock) {
                bytecodeLogWriter.println(logLine);
            }
        }
    }
    
    private static String formatMessage(String format, Object[] args) {
        if (args == null || args.length == 0) return format;
        
        StringBuilder sb = new StringBuilder(format.length() + args.length * 16);
        int argIndex = 0;
        int len = format.length();
        
        for (int i = 0; i < len; i++) {
            char c = format.charAt(i);
            if (c == '{' && i + 1 < len && format.charAt(i + 1) == '}') {
                if (argIndex < args.length) {
                    sb.append(args[argIndex++]);
                } else {
                    sb.append("{}");
                }
                i++;
            } else {
                sb.append(c);
            }
        }
        
        return sb.toString();
    }
    
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    // SECTION 9 — CONFIGURATION
    //══════════════════════════════════════════════════════════════════════════════════════════════════════════════
    
    /**
     * Enable or disable bytecode logging.
     */
    public static void setBytecodeLoggingEnabled(boolean enabled) {
        bytecodeLoggingEnabled = enabled;
    }
    
    /**
     * Enable or disable metrics collection.
     */
    public static void setMetricsEnabled(boolean enabled) {
        metricsEnabled = enabled;
    }
    
    /**
     * Flush and close the bytecode log.
     */
    public static void shutdown() {
        if (bytecodeLogWriter != null) {
            synchronized (logLock) {
                // Write footer
                bytecodeLogWriter.println();
                bytecodeLogWriter.println("╔══════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗");
                bytecodeLogWriter.println("║                                      END OF LOG                                                                   ║");
                bytecodeLogWriter.println("║                                                                                                                  ║");
                bytecodeLogWriter.println("║  Shutdown Time: " + LocalDateTime.now().format(LOG_TIME_FORMAT) + "                                                                ║");
                bytecodeLogWriter.println("╚══════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝");
                bytecodeLogWriter.println();
                bytecodeLogWriter.println(Metrics.getSummary());
                bytecodeLogWriter.flush();
                bytecodeLogWriter.close();
                bytecodeLogWriter = null;
            }
        }
    }
}
