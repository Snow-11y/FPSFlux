/**
 * FpsFlux Mod Build Configuration
 * Cleanroom MC - Java 25
 */

import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'java'
    id 'java-library'
    id 'maven-publish'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.3'
    id 'com.gtnewhorizons.retrofuturagradle' version '2.0.2'
}

// ============== HELPER METHODS ==============
def propertyString(String name) {
    return project.hasProperty(name) ? project.property(name).toString() : ''
}

def propertyBool(String name) {
    return project.hasProperty(name) ? project.property(name).toString().toBoolean() : false
}

def propertyStringList(String name, String delimiter = ' ') {
    if (!project.hasProperty(name)) return []
    def value = project.property(name).toString().trim()
    return value.isEmpty() ? [] : value.split(delimiter).collect { it.trim() }
}

// ============== MOD PROPERTIES ==============
version = propertyString('mod_version')
group = propertyString('root_package')

base {
    archivesName.set(propertyString('mod_id'))
}

// ============== JAVA 25 CONFIGURATION ==============
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(25))
    }
    if (propertyBool('generate_sources_jar')) {
        withSourcesJar()
    }
    if (propertyBool('generate_javadocs_jar')) {
        withJavadocJar()
    }
}

// ============== CONFIGURATIONS ==============
configurations {
    embed
    implementation.extendsFrom(embed)
}

// ============== MINECRAFT CONFIGURATION ==============
minecraft {
    mcVersion.set('1.12.2')

    mcpMappingChannel.set(propertyString('mapping_channel'))
    mcpMappingVersion.set(propertyString('mapping_version'))

    useDependencyAccessTransformers.set(propertyBool('use_dependency_at_files'))

    username.set(propertyString('minecraft_username'))

    extraTweakClasses.addAll(propertyStringList('extra_tweak_classes'))

    def args = ["-ea:${propertyString('root_package')}"]
    if (propertyBool('use_mixins')) {
        args << '-Dmixin.hotSwap=true'
        args << '-Dmixin.checks.interfaces=true'
        args << '-Dmixin.debug.export=true'
    }
    extraRunJvmArguments.addAll(args)
    extraRunJvmArguments.addAll(propertyStringList('extra_jvm_args'))
}

// ============== REPOSITORIES ==============
repositories {
    maven {
        name 'CleanroomMC Maven'
        url 'https://maven.cleanroommc.com'
    }
    maven {
        name 'SpongePowered Maven'
        url 'https://repo.spongepowered.org/maven'
    }
    mavenCentral()
}

// ============== DEPENDENCIES ==============
dependencies {
    if (propertyBool('use_asset_mover')) {
        implementation "com.cleanroommc:assetmover:${propertyString('asset_mover_version')}"
    }

    if (propertyBool('use_mixins')) {
        String mixinDep = modUtils.enableMixins(
            "zone.rong:mixinbooter:${propertyString('mixin_booter_version')}",
            propertyString('mixin_refmap')
        )
        api(mixinDep) {
            transitive = false
        }
        annotationProcessor 'org.ow2.asm:asm-debug-all:5.2'
        annotationProcessor 'com.google.guava:guava:32.1.2-jre'
        annotationProcessor 'com.google.code.gson:gson:2.8.9'
        annotationProcessor(mixinDep) {
            transitive = false
        }
    }

    if (propertyBool('enable_junit_testing')) {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
        testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    }
}

// ============== ACCESS TRANSFORMERS ==============
if (propertyBool('use_access_transformer')) {
    for (def location : propertyStringList('access_transformer_locations')) {
        def fileLocation = file("${projectDir}/src/main/resources/${location}")
        if (fileLocation.exists()) {
            tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from(fileLocation)
            tasks.srgifyBinpatchedJar.accessTransformerFiles.from(fileLocation)
        } else {
            throw new GradleException("Access Transformer file [${fileLocation}] does not exist!")
        }
    }
}

// ============== PROCESS RESOURCES ==============
processResources {
    inputs.property 'mod_id', propertyString('mod_id')
    inputs.property 'mod_name', propertyString('mod_name')
    inputs.property 'mod_version', propertyString('mod_version')
    inputs.property 'mod_description', propertyString('mod_description')
    inputs.property 'mod_authors', propertyStringList('mod_authors', ',').join(', ')
    inputs.property 'mod_credits', propertyString('mod_credits')
    inputs.property 'mod_url', propertyString('mod_url')
    inputs.property 'mod_update_json', propertyString('mod_update_json')
    inputs.property 'mod_logo_path', propertyString('mod_logo_path')
    inputs.property 'mixin_refmap', propertyString('mixin_refmap')

    def filterList = ['mcmod.info', 'pack.mcmeta']

    if (propertyBool('use_mixins')) {
        filterList.addAll(propertyStringList('mixin_configs').collect { "mixins.${it}.json" as String })
    }

    filesMatching(filterList) { fcd ->
        fcd.expand(
            'mod_id': propertyString('mod_id'),
            'mod_name': propertyString('mod_name'),
            'mod_version': propertyString('mod_version'),
            'mod_description': propertyString('mod_description'),
            'mod_authors': propertyStringList('mod_authors', ',').join(', '),
            'mod_credits': propertyString('mod_credits'),
            'mod_url': propertyString('mod_url'),
            'mod_update_json': propertyString('mod_update_json'),
            'mod_logo_path': propertyString('mod_logo_path'),
            'mixin_refmap': propertyString('mixin_refmap')
        )
    }

    if (propertyBool('use_access_transformer')) {
        rename '(.+_at.cfg)', 'META-INF/$1'
    }
}

// ============== JAR CONFIGURATION ==============
jar {
    manifest {
        def attributeMap = [:]

        if (propertyBool('is_coremod')) {
            attributeMap['FMLCorePlugin'] = propertyString('coremod_plugin_class_name')
            if (propertyBool('coremod_includes_mod')) {
                attributeMap['FMLCorePluginContainsFMLMod'] = 'true'
                def currentTasks = gradle.startParameter.taskNames
                if (currentTasks.any { it in ['build', 'prepareObfModsFolder', 'runObfClient'] }) {
                    attributeMap['ForceLoadAsMod'] = 'true'
                }
            }
        }

        if (propertyBool('use_access_transformer')) {
            attributeMap['FMLAT'] = propertyString('access_transformer_locations')
        }

        attributes(attributeMap)
    }

    from(provider { configurations.embed.collect { it.isDirectory() ? it : zipTree(it) } })
}

// ============== JAVA COMPILATION (Java 25 -> Java 8 bytecode) ==============
tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.compilerArgs << '-Xlint:-options'

    if (it.name in ['compileMcLauncherJava', 'compilePatchedMcJava']) {
        return
    }

    sourceCompatibility = 25
    targetCompatibility = 8
}

// ============== TEST CONFIGURATION ==============
compileTestJava {
    sourceCompatibility = targetCompatibility = 8
}

test {
    useJUnitPlatform()
    if (propertyBool('show_testing_output')) {
        testLogging {
            showStandardStreams = true
        }
    }
}

// ============== IDEA CONFIGURATION ==============
idea {
    module {
        inheritOutputDirs = true
    }
    project {
        settings {
            runConfigurations {
                "1. Run Client"(Gradle) {
                    taskNames = ['runClient']
                }
                "2. Run Server"(Gradle) {
                    taskNames = ['runServer']
                }
                "3. Run Obfuscated Client"(Gradle) {
                    taskNames = ['runObfClient']
                }
                "4. Run Obfuscated Server"(Gradle) {
                    taskNames = ['runObfServer']
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                        (project.name + '.main'): tasks.compileJava.options.compilerArgs.collect { "\"${it}\"" }.join(' ')
                    ]
                }
            }
        }
    }
}

// ============== HELPER TASKS ==============
tasks.register('generateMixinJson') {
    group = 'cleanroom helpers'
    description = 'Generates missing mixin configuration JSON files'

    onlyIf {
        if (propertyBool('use_mixins') && propertyBool('generate_mixins_json')) {
            def configs = propertyStringList('mixin_configs')
            return configs.any { !file("src/main/resources/mixins.${it}.json").exists() }
        }
        return false
    }

    doLast {
        for (String mixinConfig : propertyStringList('mixin_configs')) {
            def mixinFile = file("src/main/resources/mixins.${mixinConfig}.json")
            if (!mixinFile.exists()) {
                mixinFile.parentFile.mkdirs()
                mixinFile.text = """{
    "package": "${propertyString('root_package')}.mixin",
    "required": true,
    "refmap": "${propertyString('mixin_refmap')}",
    "target": "@env(DEFAULT)",
    "minVersion": "0.8.5",
    "compatibilityLevel": "JAVA_8",
    "mixins": [],
    "server": [],
    "client": []
}"""
                println "Generated: ${mixinFile.path}"
            }
        }
    }
}

tasks.register('prioritizeCoremods') {
    group = 'cleanroom helpers'
    description = 'Renames core mods to load first'
    dependsOn 'prepareObfModsFolder'

    doLast {
        fileTree('run/obfuscated').forEach { file ->
            if (file.isFile() && file.name =~ '(mixinbooter|configanytime)(-)([0-9])+\\.+([0-9])+(.jar)') {
                file.renameTo(new File(file.parentFile, "!${file.name}"))
            }
        }
    }
}

tasks.named('prepareObfModsFolder').configure {
    finalizedBy 'prioritizeCoremods'
}

tasks.register('cleanroomAfterSync') {
    group = 'cleanroom helpers'
    description = 'Tasks to run after Gradle sync'
    dependsOn 'generateMixinJson'
}

idea.project.settings {
    taskTriggers {
        afterSync 'cleanroomAfterSync'
    }
}

// ============== PUBLISHING ==============
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifactId = propertyString('mod_id')
        }
    }
    repositories {
        if (propertyBool('publish_to_local_maven')) {
            mavenLocal()
        }
    }
}
